# Item & Inventory System — Technical Specification (UE 5.6.1)

## Goals and Scope
- Provide a flexible, volume-based inventory for the player with a vertical hotbar (1–9) docked to the left side of the screen.
- Support picking up world Item Objects via R while looking at them.
- Provide contextual USE behavior per item, with additional DROP, EQUIP, and STORE actions via a right-click context menu in the inventory UI.
- Support interacting with storage containers: inventory screen shows a second panel for storage items and adds a STORE action.
- Show an item’s description and generated icon/picture when selected, plus an equipment section with slots on the right side of the inventory screen.
- Present a scrollable list UI for inventory contents and support hotbar assignment via keys 1–9.
- Generate item icons programmatically via snapshots of the item objects.

## Out of Scope (Initial Phase)
- Weapon firing or consumption logic beyond the generic USE/ATTACK hooks.
- Multiplayer support: explicitly not planned for this project.
- Controller support: not planned initially (may be added later).
- Drag-and-drop UI (right-click actions only for v1; drag and drop can arrive later).

## Player Experience and UX

### Hotbar
- Always visible vertical strip along the left edge with slots 1–9.
- Each slot shows the item icon and a small count label (aggregated count per item type); highlight the currently selected slot.
- Pressing 1–9 holds/selects the item in that slot in-hand (no immediate use).
- Holding a number key while the inventory is open assigns the selected item type to that slot.

### Picking Up Items
- Press R to pick up the item while looking at it. If there is insufficient volume, push a message to the top-right message log (e.g., "Inventory full").
- Holding E performs the object's USE context action (with a progress bar) rather than picking it up.

### Inventory Screen
- Open via a bound key (Tab or I). Pauses character control but not game time (configurable later).
- Left panel: scrollable list of inventory items with compact rows (icon, name, aggregated count per item type, total volume for the type, optional rarity color strip).
- Right panel: equipment view (slots) at the top and selected item details (large icon, description, metadata) beneath.
- When interacting with a storage container, show an additional panel listing storage items (Left of inventory panel); right-click context menu adds STORE for player inventory entries and TAKE for storage entries.

### Context Menu
- Default actions: HOLD, USE, DROP, EQUIP (if equippable), ASSIGN TO HOTBAR… (submenu 1–9).
- With storage open: STORE on player inventory entries, TAKE on storage entries, and STORE ALL (moves all items of the same type to storage subject to capacity).

### Icons and Previews
- Item icons are auto-generated by capturing the item’s mesh into a `UTexture2D` using a `USceneCaptureComponent2D`.
- Generated icons are cached in memory and optionally serialized to `Saved/ItemIcons` for faster reloads.

## Core Concepts and Data Model

### Item Definition (Data)
- `UItemDefinition` (`UPrimaryDataAsset` or `UDataAsset`) provides immutable metadata shared by all instances.
  - Guid, Name, DisplayName.
  - Mesh or Actor class for pickup visualization.
  - Volume per unit (float, liters or project-specific units).
  - Tags and capabilities (`FGameplayTagContainer`) such as Equippable, Consumable, Ammo, Tool.
  - Equipment slot type (`EEquipmentSlot`) when applicable.
  - Default description text (localized) and optional icon override.
  - Use behavior reference (`UItemUseAction` class) or tag-script mapping.

### Item Instance (Runtime)
- `FItemEntry` value type for containers: `{ UItemDefinition* Def; FGuid ItemId; TMap<FName, FString> CustomData; }` (one entry per unit; no stacks).
- Optional `UItemInstance` UObject for per-instance state (durability, attachments, randomized stats)

### Containers
- `UInventoryComponent`: owned by player, capacity expressed in max volume (float), stores `TArray<FItemEntry>`.
- `UStorageComponent`: mirrors inventory interface for world containers (chests, lockers) with customizable capacity and rules.
- `UItemContainerLibrary`: shared helper for add/remove/transfer operations with validation and events.

### Volume Rules
- Total used volume = `sum(Def->VolumePerUnit for each FItemEntry)` across all entries.
- Adding an item fails if `UsedVolume + Entry.Def->VolumePerUnit > MaxVolume`.
- No stack merging; each carried unit is its own entry. UI may aggregate counts per item type for display only.

### Equipment
- `EEquipmentSlot`: initial set includes Head, Chest, Hands, Back, Primary, Secondary, Utility, Gadget.
- `UEquipmentComponent`: map of `EEquipmentSlot → FItemEntry` (one unit per slot); emits events on equip/unequip to attach meshes, grant abilities, or adjust stats.

## Systems and Interactions

### Pickup Actors
- `AItemPickup` represents a world item unit with mesh, collision, and a payload of `UItemDefinition + ItemId + CustomData`.
- While looking at a pickup: Press R to add it to the inventory (line trace confirms target). On success, destroy the pickup; on failure, push a message (e.g., "Inventory full"). Holding E performs the object's USE context action instead (does not pick up).

### Storage Actors
- Actors with `UStorageComponent` implement `IInteractable`. On interact, open the inventory UI in dual-pane mode.
- Transfers reuse shared add/remove/merge logic with capacity checks on both sides.

### Use and Attack Actions
- `UItemUseAction` abstract base exposes `bool Execute(ACharacter* User, FItemEntry& Item, FItemContext Context)`.
- Optional `UItemAttackAction` base exposes `bool ExecuteAttack(ACharacter* User, FItemEntry& Item, FItemContext Context)`; triggered by LMB when held.
- Concrete actions: `UUseAction_Consume`, `UUseAction_Equip`, `UUseAction_Place`, `UUseAction_Tool`, etc.
- Item definitions reference their default action classes, or a tag router resolves a registered action set.
- USE is triggered via RMB when an item is held, or via hold‑E where contextual; actions may destroy the item entry or modify its `CustomData` and return success/failure.

### Hotbar Component
- `UHotbarComponent`: 9 slots. Each slot references a `UItemDefinition*` (type) and an optional currently held `FGuid ItemId` for the active unit.
- Selecting a slot (press 1–9) updates `ActiveHotbarIndex` and HOLDS the item in hand (no immediate use). If multiple units exist, pick a deterministic one (e.g., first entry) and set `ItemId`.
- Holding 1–9 while an item is selected in the inventory assigns that item type to the slot.

## UI Architecture (UMG)

### Widgets
- `UHotbarWidget` (always visible, left vertical bar).
- `UInventoryScreenWidget` (modal):
  - Left panel (conditional): `UStorageListWidget` shown when storage is open.
  - Middle panel: `UInventoryListWidget` with a `UListView` or `SListView` of `UInventoryItemEntryWidget` rows.
  - Right panel: `UEquipmentPanelWidget` (grid or list of slots) and `UItemDetailsWidget` showing icon, name, description, metadata.
  - `UContextMenuWidget` for right-click actions, positioned near the cursor.

### Behaviors
- Scroll to view items via mouse wheel or scrollbar.
- Right-click opens the context menu; entries derive from item capabilities, current context (player vs storage), and availability (e.g., EQUIP only for equippables with a free slot).
- On selection change, update the details panel and large preview icon.
- Dual-pane mode: when storage is open, both lists are interactable and show STORE/TAKE for relevant entries.

### Visuals and State
- Highlight the selected row; indicate equipped items (overlay icon on list or hotbar slot).
- Display a volume bar showing used vs max volume at the top of the inventory screen.

## Input and Controls (Enhanced Input)

### New Input Actions
- `IA_Pickup` (R): while looking at an item pickup, add it to the inventory.
- `IA_Interact` (E, Hold): context-sensitive hold with progress bar; performs the object's USE action (e.g., operate devices, consume context items) and opens storage when applicable. Does not pick up items.
- `IA_OpenInventory` (Tab/I): toggle inventory UI.
- `IA_Hotbar1` … `IA_Hotbar9` (1–9): hold/select item to hand; with inventory open and an item selected, assigns to that slot.
- `IA_Primary` (LMB): with a held item, trigger ATTACK if available.
- `IA_Secondary` (RMB): with a held item, trigger USE.
- Optional future actions: `IA_Drop`. 

### Integration Points
- Bind input in `AFirstPersonCharacter` or `AFirstPersonPlayerController`, following existing project patterns (Enhanced Input already a dependency).

## Icon Generation Pipeline

### Runtime Thumbnail Capture
- Create a hidden thumbnail scene using a lightweight `USceneCaptureComponent2D`, camera at a canonical angle, and neutral lighting (sky light or directional light).
- Spawn/attach the item mesh (from `UItemDefinition`) in a transient scene; render to `UTextureRenderTarget2D`.
- Convert to `UTexture2D` for UI use. Cache in a `Def → Texture` map and optionally write to `Saved/ItemIcons` for persistence.

### Performance
- Generate lazily on first demand or batch during loading screens.
- Cap resolution (e.g., 256x256) and reuse components to avoid per-item overhead.

## Error Handling and Edge Cases
- Adding beyond capacity fails with feedback; partial adds allowed only for stackable items up to capacity (configurable, default allows partial with prompt).
- Splitting stacks prompts for quantity; validate counts and capacity when transferring between containers.
- Equipping a stack typically consumes one unit into equipment; remainder stays in inventory.
- Dropping an equipped item automatically unequips before spawning the pickup with correct mesh and count.
- Close storage UI automatically if the player moves out of range or the storage actor is destroyed.
- Missing icon meshes fall back to a default placeholder icon.

## Save/Load and Persistence
- Persist player inventory, hotbar assignments, and equipment via `USaveGame` (e.g., `UPlayerInventorySave`).
- Serialize world pickups and storage inventories as level actors (guid + count + transform for pickups; container GUID for storages).
- On load, reconstruct pickups and storage contents from saved data.

## Extensibility and Future Multiplayer
- Container interfaces leverage an abstract `IItemContainer` API to enable AI inventories, vendors, etc.
- Future multiplayer support: replicate components with owner-only relevancy for inventory lists, gate UI actions behind authoritative RPCs, and keep hotbar selection locally predicted.

## Telemetry and Debugging
- Add `UE_LOG(LogInventory, Verbose, ...)` entries for container operations.
- Expose console commands: `inv.add <ItemId> <Count>`, `inv.debug on|off`, `inv.fill`, `inv.clear` (dev only).
- Provide automation tests covering capacity, merges, transfers, and action gating.

## C++ Class and File Layout (Proposed)
- `Source/Unknown/Public/Items`
  - `ItemDefinition.h/.cpp` (`UItemDefinition : UPrimaryDataAsset`)
  - `ItemUseAction.h/.cpp` (base plus derived actions in subfolder)
  - `ItemTypes.h` (`FItemStack`, enums, helpers)
- `Source/Unknown/Public/Inventory`
  - `InventoryComponent.h/.cpp`
  - `EquipmentComponent.h/.cpp`
  - `HotbarComponent.h/.cpp`
  - `StorageComponent.h/.cpp`
  - `ItemContainerLibrary.h/.cpp` (add/remove/merge/split/transfer)
- `Source/Unknown/Public/Actors`
  - `ItemPickup.h/.cpp`
  - `StorageActor.h/.cpp` (example chest with `UStorageComponent`)
- `Source/Unknown/Public/UI`
  - `HotbarWidget.h/.cpp`
  - `InventoryScreenWidget.h/.cpp`
  - `InventoryItemEntryWidget.h/.cpp`
  - `EquipmentPanelWidget.h/.cpp`
  - `ItemDetailsWidget.h/.cpp`
  - `ContextMenuWidget.h/.cpp`
- Integration: extend `AFirstPersonCharacter` to own `UInventoryComponent`, `UEquipmentComponent`, and `UHotbarComponent`, and handle input plus traces.

## Key Algorithms and Pseudocode

### Add Item to Container

```cpp
bool UInventoryComponent::TryAdd(const FItemStack& Incoming, FItemStack& Remainder)
{
    float AddedVolume = Incoming.Count * Incoming.Def->VolumePerUnit;
    float CapacityLeft = MaxVolume - GetUsedVolume();

    int32 CanFitCount = FMath::FloorToInt(CapacityLeft / Incoming.Def->VolumePerUnit);
    int32 ToAdd = FMath::Clamp(CanFitCount, 0, Incoming.Count);

    if (ToAdd <= 0)
    {
        Remainder = Incoming;
        return false;
    }

    // Merge into existing stacks up to MaxStack
    MergeIntoExistingStacks(Incoming.Def, ToAdd);

    // Create new stack(s) if needed while respecting MaxStack
    CreateNewStacksAsNeeded(Incoming.Def, ToAdd);

    Remainder = Incoming;
    Remainder.Count -= ToAdd;
    OnInventoryChanged.Broadcast();
    return Remainder.Count == 0;
}
```

### Transfer Player → Storage (STORE)

```cpp
bool UItemContainerLibrary::Transfer(UInventoryComponent* From, UInventoryComponent* To, const FItemRef& Ref, int32 Count)
{
    FItemStack Extracted = From->Extract(Ref, Count);
    FItemStack Remainder;

    if (!To->TryAdd(Extracted, Remainder))
    {
        // Roll back if not fully transferred
        if (Remainder.Count < Extracted.Count)
        {
            From->TryAdd(Extracted, /*out*/ Extracted);
        }
        return false;
    }

    return true;
}
```

## UI State and Flow Summaries
- **Normal Play:** HUD shows hotbar; crosshair aim + R picks up items.
- **Inventory Open:** Left panel shows player items (scrollable); right panel shows equipment and details; context menu available via right-click.
- **Storage Interaction:** Inventory opens in dual-pane mode; context menu includes STORE/TAKE; show volume bars for each container.

## Config and Content
- `Build.cs`: confirm dependencies (Core, CoreUObject, Engine, InputCore, EnhancedInput, UMG, Slate, SlateCore).
- Project Settings: configure Enhanced Input mapping contexts; ensure `IncludeOrderVersion = Unreal5_6`.
- Data: create `UItemDefinition` assets under `/Game/Items/` with correct volume and stack properties.

## Testing Plan (Automation)
- Unit/Automation tests (`Source/Unknown/Private/Tests`):
  - `Project.Inventory.AddCapacity`: add items up to volume limit; verify remainder.
  - `Project.Inventory.MergeStacks`: add identical items twice; expect merge respecting `MaxStack`.
  - `Project.Inventory.Transfer`: validate player ↔ storage transfers with partial fits.
  - `Project.Inventory.Equip`: equipping moves one count to slot and fires relevant events.
  - `Project.Inventory.Hotbar`: assign via key simulation; selecting slot exposes correct active item.
  - `Project.Inventory.IconGen`: icon texture generated and cached for a sample definition.
- Execute via `UnrealEditor-Cmd.exe` with repository-specified flags (EditorContext | ProductFilter).

## Milestones and Incremental Delivery
1. **Foundations**
   - Data model (`UItemDefinition`, `FItemStack`), `UInventoryComponent`, simple `AItemPickup`, basic HUD hotbar.
   - Implement R pickup flow and capacity checks; add minimal test coverage.
2. **UI v1**
   - Inventory screen with list + scrolling, selection, details panel, right-click context menu (USE, DROP).
3. **Equipment and Actions**
   - `UEquipmentComponent`, EQUIP flow, USE action routing; implement basic actions (consume/equip).
4. **Storage**
   - `UStorageComponent`, dual-pane UI, STORE/TAKE transfers, distance-based auto-close.
5. **Icons**
   - Runtime snapshot pipeline with caching and fallbacks.
6. **Polish and Tests**
   - Volume bars, indicators, edge cases, expanded tests, save/load support.

## Risks and Mitigations
- Icon generation performance: use lazy generation, caching, resolution caps, and shared capture scenes.
- Complex UI state: keep UI controllers thin, drive state from component events, and write focused widget tests.
- Future replication: keep all inventory mutations behind a single API; avoid UI-side mutations.

## Acceptance Criteria
- Player can pick up items with R while looking at them; inventory capacity enforced by volume.
- Hotbar visible on the left with nine slots; number keys select slots and allow assignment from inventory.
- Inventory screen shows scrollable list, item details (description + picture), and equipment panel on the right.
- Right-click menu includes USE, DROP, EQUIP, and, when applicable, STORE/TAKE.
- Interacting with a storage container shows a second list and allows transfers respecting capacity.
- Item icons auto-generate and display in the UI.
- Automation tests cover core flows and pass headlessly.

## Open Questions
- Exact equipment slot taxonomy and simultaneous equipment limits per category.
- Whether USE on hotbar should default to equip (toggle) or execute consumable behavior.
- Should partial adds automatically proceed or require confirmation when near capacity?
- Standards for controller/keyboard navigation within the inventory UI.
- Save cadence (on pickup/equip vs checkpoints only).


## Revision 2025-11-13 — HOLD items, no stacks, terminal UI, message log, inputs update

This section updates and supersedes any conflicting parts of earlier sections in this document.

### Core Behavior Changes
- HOLD vs USE
  - Pressing hotbar keys 1–9 now HOLDS the item in that slot in the character’s hand. It does NOT immediately use it.
  - A held item is attached to a hand socket (tool-like), not physics-held. Add a dedicated mesh/socket (e.g., `Mesh->GetMesh()->AttachToComponent(FirstPersonMesh, HandSocket)`), and ensure proper FP/TP visibility.
  - Left Mouse Button with a held item triggers the item’s `ATTACK` action (if available). If the item has no `ATTACK`, LMB does nothing by default.
  - Right Mouse Button with a held item triggers the item’s `USE` action (contextual use).
- Using items via hold-to-Interact (E)
  - Holding E performs context-sensitive interaction with a visible progress bar.
  - For items: Holding E will perform the `USE` action when the bar fills (wherever contextual; e.g., consuming a medkit).
  - For storage actors and other interactables: Holding E opens or activates them when the bar fills.
- Physics pickup stays separate from HOLD
  - Physics-based picking up/interaction still uses E (hold to complete interaction). This is distinct from HOLDing an item in hand (hotbar selection).

### Inventory Model — No Stacks
- There are no stack sizes. The inventory capacity is purely volume-based.
- You can carry multiple units of the same item as long as total volume allows.
- Data change: Replace `FItemStack { Def, Count }` with `FItemEntry { UItemDefinition* Def; FGuid ItemId; TMap<FName, FString> CustomData; }` (one entry per item unit). Inventories store `TArray<FItemEntry>`.
- UI should still show aggregated counts per item type in the list (computed on the fly), displaying total count and total volume for that type.

### Context Menu Updates
- Add `HOLD` (selects and holds the item in-hand via the appropriate hotbar slot, or sets it as Active without consuming).
- Add `STORE ALL` (moves all items of the same type from the player inventory to the open storage, respecting volume).
- Remove `SPLIT STACK` (stacks are no longer a concept).
- Keep: `USE`, `DROP`, `EQUIP` (if equippable), `ASSIGN TO HOTBAR…` (submenu 1–9), `TAKE` (on storage items when applicable).

### Hotbar Behavior
- Pressing 1–9: hold/select the item in that slot (no immediate use).
- With the inventory screen open and an item selected, holding a number key still assigns that item type to the slot.
- `ActiveHotbarIndex` reflects the currently held item.

### Input Map (updated)
- `IA_Interact` (E, Hold): context-sensitive, shows progress bar, triggers interaction on fill.
  - World pickups, storage actors, and contextual `USE` fall under this input when no item is held or when appropriate.
- `IA_Hotbar1..9` (1–9): hold/select item to hand (no immediate use).
- `IA_Primary` (LMB): with held item, trigger `ATTACK` if defined.
- `IA_Secondary` (RMB): with held item, trigger `USE`.
- `IA_OpenInventory` (Tab/I): open/close inventory.

### UI Style — Terminal Theme
- All inventory and related UI should adopt a terminal-like style: black background, white borders, monochrome lines, and simple typography.
- Hotbar: vertical, left side; black panels with white 1–9 labels and white outline rectangles.
- Inventory list, storage list, equipment panel, and context menu all use black backgrounds with white border strokes. Selected items invert colors or use a white border accent.
- Progress bar for hold-to-interact/use uses a simple white-outline rectangle with a white fill growing left-to-right on a black background.

### Message Log (Top-right HUD)
- Add a reusable `MessageLogWidget` in the top-right corner.
- Behavior:
  - Messages stack vertically downward.
  - Each message fades out and is removed after ~1 second (configurable, default 1.0–1.5s).
  - Provide an API: `LogTransientMessage(FText Text, float Duration = 1.0f)`; expose to both inventory/storage systems and general gameplay (e.g., “Inventory full”, “Stored all x3 Medkits”).

### Drop Behavior
- Dropping items must spawn an `AItemPickup` using the same definition and data.
- Ensure the spawned actor:
  - Is simulating physics (where appropriate for the mesh/actor type).
  - Has collision enabled on the project’s Interactable channel so it is detectable and pickable again.
  - Carries the same `UItemDefinition` reference and any `CustomData` from `FItemEntry`.

### Storage Interaction
- Storage actors are interacted with by holding E (progress bar). When successful, the dual-pane inventory UI opens.
- `STORE ALL` action iterates all `FItemEntry` with matching `UItemDefinition` and attempts to move all to the storage, respecting its remaining volume.

### Systems & Implementation Deltas
- Data Types
  - Replace `FItemStack` with `FItemEntry` (no Count). Inventories hold `TArray<FItemEntry>`.
  - Aggregation helpers provide counts/total volume per `UItemDefinition` for UI display and actions like `STORE ALL`.
- Inventory/Storage Components
  - `TryAdd(const FItemEntry& Entry)` returns false if adding would exceed volume capacity.
  - `RemoveById(const FGuid& ItemId)` removes a specific unit.
  - `FindAllByDef(const UItemDefinition* Def)` returns indices/handles for STORE ALL.
  - `TransferAllOfType(From, To, Def)` utility in `UItemContainerLibrary`.
- Use/Attack Actions
  - `UItemUseAction` continues to define `USE` behavior.
  - Add optional `UItemAttackAction` interface/base; items may implement `ATTACK` separately.
- Hotbar Component
  - Slots reference a representative `UItemDefinition` plus an optional currently held `FGuid ItemId` for the active unit.
  - On HOLD/select, if multiple units exist, pick one deterministically (e.g., first in list) and set as active.
- Character Integration
  - Add a skeletal mesh socket for held items (e.g., `Hand_R_Socket`).
  - On hotbar selection, spawn/attach the held item visual (if needed) or attach a representation component; hide when no item held.
  - Input handling routes LMB/RMB to `ATTACK`/`USE` of the currently held item, if present.
- Progress Bar
  - `UHoldProgressWidget` shown near crosshair or center screen while holding E; cancels if E released.

### Algorithms (Revised Pseudocode)
- Add Item (no stacks)
```
bool UInventoryComponent::TryAdd(const FItemEntry& Entry)
{
    const float CapacityLeft = MaxVolume - GetUsedVolume();
    const float V = Entry.Def ? Entry.Def->VolumePerUnit : 0.f;
    if (V <= 0.f) { return false; }
    if (V > CapacityLeft) { return false; }
    Items.Add(Entry);
    OnInventoryChanged.Broadcast();
    return true;
}
```
- Store All of Type
```
int32 UItemContainerLibrary::TransferAllOfType(UInventoryComponent* From, UInventoryComponent* To, const UItemDefinition* Def)
{
    TArray<FGuid> FromIds = From->FindAllIdsByDef(Def);
    int32 Moved = 0;
    for (const FGuid& Id : FromIds)
    {
        FItemEntry Entry;
        if (From->ExtractById(Id, Entry))
        {
            if (To->TryAdd(Entry)) { ++Moved; }
            else { From->TryAdd(Entry); /* rollback if full */ }
        }
    }
    return Moved;
}
```

### Acceptance Criteria Additions
- Pressing 1–9 holds the corresponding hotbar item in-hand; it does not auto-use.
- With a held item: LMB triggers ATTACK if present; RMB triggers USE.
- Holding E shows a progress bar and performs the context action (use item or open storage) when filled.
- Context menu contains HOLD and STORE ALL (and removes Split Stack).
- Inventory capacity is volume-only; multiple units of the same item are allowed without stacks.
- Terminal-style UI visuals (black background, white borders) across inventory, storage, hotbar, context menu, and progress bar.
- Message log appears in the top-right, stacks transient messages, and auto-clears after ~1 second.
- Dropped items become physics-enabled pickups with interactable collision and identical data.
- Multiplayer support is explicitly out of scope.



## Implementation progress (v0.3)

This version introduces visible UI widgets (built via `RebuildWidget()` with Slate `Box` brushes), robust input gating while the inventory is open, and the first test item with a basic pickup flow.

### UI runtime updates
- Hotbar HUD (`Source/Unknown/Public/UI/HotbarWidget.h`, `Private/UI/HotbarWidget.cpp`)
  - UMG tree is built in `RebuildWidget()` (prevents `SSpacer`).
  - Slots use `UBorder` with `FSlateBrush.DrawAs = Box` for terminal-style visuals.
  - Added `SetDesiredSizeInViewport` and `USizeBox` per-slot to guarantee non-zero size even without icons.
- Inventory Screen (`Source/Unknown/Public/UI/InventoryScreenWidget.h`, `Private/UI/InventoryScreenWidget.cpp`)
  - Terminal-style panel using outer/inner `UBorder` with `DrawAs = Box` brushes.
  - Header and hint, plus placeholder `UInventoryListWidget` integration point.

### Input and UX behavior while inventory is open
- Player Controller: `Source/Unknown/Private/Player/FirstPersonPlayerController.cpp`
  - Toggle with Tab (primary) or I (fallback).
  - On open: `FInputModeUIOnly`, `SetIgnoreLookInput(true)`, `SetIgnoreMoveInput(true)`, show cursor; number keys (1–9) disabled.
  - On close: `FInputModeGameOnly`, restore look/move input, hide cursor.
  - `OnLook`/`OnInteract`/`OnThrow`/`OnRotateHeld*` handlers early-return while UI is open so LMB dragging does not rotate the camera.
  - Interact highlight widget stays hidden while inventory is open and is not recomputed in `PlayerTick`.

### First test item and pickup flow
- Item base: `Source/Unknown/Public/Inventory/ItemDefinition.h` (existing).
- New concrete def: `Source/Unknown/Public/Inventory/CrowbarDefinition.h`, impl `Private/Inventory/CrowbarDefinition.cpp`
  - Defaults: DisplayName = "Crowbar", VolumePerUnit ≈ 3.0.
- World pickup actor: `Source/Unknown/Public/Inventory/ItemPickup.h`, impl `Private/Inventory/ItemPickup.cpp`
  - Root `UStaticMeshComponent` uses QueryOnly collision and blocks the project Interactable trace channel (GameTraceChannel1).
  - Defaults to Engine BasicShapes Cube mesh at reduced scale.
- Controller bindings:
  - R → Pick up: line trace for `AItemPickup`; if `UItemDefinition` valid and `UInventoryComponent::TryAdd` succeeds, destroy the pickup.
  - P (development) → Spawn a crowbar pickup ~200uu in front of camera for testing.

### How to try (PIE)
1) Build UnknownEditor (UBT command below).
2) In PIE:
   - Press Tab (or I) to open the inventory; try dragging LMB — camera should not rotate; interact highlight should remain hidden.
   - Press P to spawn a crowbar pickup in front of you.
   - Look at the pickup and press R to add to inventory; check logs for confirmation and verify counts via debug or forthcoming UI list.

### Build (UBT)
```powershell
& "C:\\Program Files\\Epic Games\\UE_5.6\\Engine\\Binaries\\DotNET\\UnrealBuildTool\\UnrealBuildTool.exe" `
  -Mode=Build `
  -Project="C:\\Users\\gchou\\Documents\\Projects\\Unknown\\Project\\Unknown\\Unknown.uproject" `
  -Target="UnknownEditor Win64 Development" `
  -WaitMutex -NoHotReloadFromIDE
```

### Tests (headless)
- Existing suites remain valid:
  - Project.Inventory, Project.Storage, Project.Transfer, Project.Hotbar
- Discover or run as previously documented in v0.2.

### Notes
- Inventory list panel (`UInventoryListWidget`), storage pane, details and equipment panels, and context menu are being implemented next; this pass focuses on robust UI visibility/gating and the first pickup path.

This section tracks what is implemented in code so other agents can quickly locate APIs, tests, and examples.

### New/updated runtime types
- Inventory container (player): `Source/Unknown/Public/Inventory/InventoryComponent.h`, impl `Private/Inventory/InventoryComponent.cpp`
  - API: `GetUsedVolume()`, `CanAdd()`, `TryAdd()`, `RemoveById()`, `CountByDef()`, `GetEntries()`
  - Events: `OnItemAdded (FItemEntry)`, `OnItemRemoved (FGuid)`
- Storage container (world): `Source/Unknown/Public/Inventory/StorageComponent.h`, impl `Private/Inventory/StorageComponent.cpp`
  - Mirrors `UInventoryComponent` API and volume rules; default `MaxVolume = 60.f` for test maps.
- Item model:
  - `Source/Unknown/Public/Inventory/ItemDefinition.h` (`UItemDefinition` data asset with `VolumePerUnit`, `Tags`, optional visuals and default use action)
  - `Source/Unknown/Public/Inventory/ItemTypes.h` (`FItemEntry { UItemDefinition* Def; FGuid ItemId; TMap<FName, FString> CustomData; }`)
- Use actions base: `Source/Unknown/Public/Inventory/ItemUseAction.h` (`UItemUseAction` abstract base)

### Transfer helpers
- Library: `Source/Unknown/Public/Inventory/ItemContainerLibrary.h`, impl `Private/Inventory/ItemContainerLibrary.cpp`
  - `GetFreeVolume(const UInventoryComponent*)`, `GetFreeVolumeStorage(const UStorageComponent*)`
  - Inventory → Storage:
    - `CanTransfer_ItemId(const UInventoryComponent* Source, const UStorageComponent* Dest, const FGuid& ItemId)`
    - `Transfer_ItemId(UInventoryComponent* Source, UStorageComponent* Dest, const FGuid& ItemId)`
  - Storage → Inventory:
    - `CanTransfer_ItemId_StorageToInv(const UStorageComponent* Source, const UInventoryComponent* Dest, const FGuid& ItemId)`
    - `Transfer_ItemId_StorageToInv(UStorageComponent* Source, UInventoryComponent* Dest, const FGuid& ItemId)`
  - Bulk convenience:
    - `MoveAllOfType(UInventoryComponent* Source, UStorageComponent* Dest, const UItemDefinition* Def)`
  - Behavior: atomic transfers. Destination add occurs first; if subsequent source removal fails, the destination addition is rolled back and events are emitted accordingly.

### Invariants and rules (for both Inventory and Storage)
- Volume rule: `Used + Entry.Def->VolumePerUnit <= MaxVolume` (with small epsilon) is required to add.
- Entries are unit-based (no stacking); UI aggregates counts by `UItemDefinition`.
- Events fire on successful `TryAdd`/`RemoveById`.
- Null `Def` entries are rejected.

### Tests (automation)
- Inventory core: `Source/Unknown/Private/Tests/InventoryComponent.spec.cpp` (prefix: `Project.Inventory.Core.*`)
- First-person character integration: `Source/Unknown/Private/Tests/FirstPersonInventory.spec.cpp`
- Storage core: `Source/Unknown/Private/Tests/StorageComponent.spec.cpp` (prefix: `Project.Storage.Core.*`)
- Transfer helpers: `Source/Unknown/Private/Tests/ItemContainerLibrary.spec.cpp` (prefix: `Project.Transfer.Core.*`)

### How to build (UBT)
```powershell
& "C:\\Program Files\\Epic Games\\UE_5.6\\Engine\\Binaries\\DotNET\\UnrealBuildTool\\UnrealBuildTool.exe" `
  -Mode=Build `
  -Project="C:\\Users\\gchou\\Documents\\Projects\\Unknown\\Project\\Unknown\\Unknown.uproject" `
  -Target="UnknownEditor Win64 Development" `
  -WaitMutex -NoHotReloadFromIDE
```

### How to run tests (headless)
- Discover tests:
```powershell
& "C:\\Program Files\\Epic Games\\UE_5.6\\Engine\\Binaries\\Win64\\UnrealEditor-Cmd.exe" `
  "C:\\Users\\gchou\\Documents\\Projects\\Unknown\\Project\\Unknown\\Unknown.uproject" `
  -unattended -nop4 -NullRHI -NoSound -NoSplash -log `
  -ExecCmds='Automation List; Quit'
```
- Run suites:
```powershell
# Inventory
& "C:\\Program Files\\Epic Games\\UE_5.6\\Engine\\Binaries\\Win64\\UnrealEditor-Cmd.exe" `
  "C:\\Users\\gchou\\Documents\\Projects\\Unknown\\Project\\Unknown\\Unknown.uproject" `
  -unattended -nop4 -NullRHI -NoSound -NoSplash -log `
  -ReportOutputPath="C:\\Users\\gchou\\Documents\\Projects\\Unknown\\Project\\Unknown\\Saved\\AutomationReports\\CLI" `
  -ExecCmds='Automation RunTests Project.Inventory; Quit'

# Storage
& "C:\\Program Files\\Epic Games\\UE_5.6\\Engine\\Binaries\\Win64\\UnrealEditor-Cmd.exe" `
  "C:\\Users\\gchou\\Documents\\Projects\\Unknown\\Project\\Unknown\\Unknown.uproject" `
  -unattended -nop4 -NullRHI -NoSound -NoSplash -log `
  -ReportOutputPath="C:\\Users\\gchou\\Documents\\Projects\\Unknown\\Project\\Unknown\\Saved\\AutomationReports\\CLI" `
  -ExecCmds='Automation RunTests Project.Storage; Quit'

# Transfer
& "C:\\Program Files\\Epic Games\\UE_5.6\\Engine\\Binaries\\Win64\\UnrealEditor-Cmd.exe" `
  "C:\\Users\\gchou\\Documents\\Projects\\Unknown\\Project\\Unknown\\Unknown.uproject" `
  -unattended -nop4 -NullRHI -NoSound -NoSplash -log `
  -ReportOutputPath="C:\\Users\\gchou\\Documents\\Projects\\Unknown\\Project\\Unknown\\Saved\\AutomationReports\\CLI" `
  -ExecCmds='Automation RunTests Project.Transfer; Quit'
```

### Notes for future work
- Hotbar (`UHotbarComponent`, 9 slots) next; tests will validate assignment and active selection.
- Pickup actor (`AItemPickup`) and interaction flow using the transfer helpers.
- Consider replacing deprecated `RemoveAtSwap(Index, 1, false)` bool parameter with `EAllowShrinking::No` in UE 5.7+ for forward compatibility.
